<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>SDK: ibeo::common::sdk::EventMonitor Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../ibeo_logo.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SDK
   &#160;<span id="projectnumber">6.0.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Home</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../dd/d32/a00041.html"><span>Data&#160;Types</span></a></li>
      <li><a href="../../d5/db6/a00042.html"><span>Examples</span></a></li>
      <li><a href="../../d3/dea/a00046.html"><span>Changelog</span></a></li>
      <li><a href="../../d3/de7/a00039.html"><span>License</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/d45/a01826.html">ibeo</a></li><li class="navelem"><a class="el" href="../../d7/d1a/a01827.html">common</a></li><li class="navelem"><a class="el" href="../../d0/dd3/a01077.html">sdk</a></li><li class="navelem"><a class="el" href="../../d0/d4a/a00147.html">EventMonitor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="../../da/df8/a03577.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ibeo::common::sdk::EventMonitor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Thread-safe handler for a group of events.  
 <a href="../../d0/d4a/a00147.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../da/d5b/a00868_source.html">sdk/source/sdk/include/ibeo/common/sdk/EventMonitor.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0ef7a5716b4d58b30bd098de2cafa9db"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4a/a00147.html#a0ef7a5716b4d58b30bd098de2cafa9db">Mask</a> = uint32_t</td></tr>
<tr class="memdesc:a0ef7a5716b4d58b30bd098de2cafa9db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type of an event mask.  <a href="#a0ef7a5716b4d58b30bd098de2cafa9db">More...</a><br /></td></tr>
<tr class="separator:a0ef7a5716b4d58b30bd098de2cafa9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9de610a54e0a03d5cbb0a354d31a2d8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4a/a00147.html#ab9de610a54e0a03d5cbb0a354d31a2d8">StandardEventMasks</a> { <a class="el" href="../../d0/d4a/a00147.html#ab9de610a54e0a03d5cbb0a354d31a2d8a09a1f410af6d0856ae7520fd3bf75e93">TimeOutEvent</a> = 0
 }<tr class="memdesc:ab9de610a54e0a03d5cbb0a354d31a2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of standard event masks.  <a href="../../d0/d4a/a00147.html#ab9de610a54e0a03d5cbb0a354d31a2d8">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab9de610a54e0a03d5cbb0a354d31a2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae1a1d19bbcf446d239930df4c1885fec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4a/a00147.html#ae1a1d19bbcf446d239930df4c1885fec">EventMonitor</a> ()</td></tr>
<tr class="memdesc:ae1a1d19bbcf446d239930df4c1885fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#ae1a1d19bbcf446d239930df4c1885fec">More...</a><br /></td></tr>
<tr class="separator:ae1a1d19bbcf446d239930df4c1885fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8323c8329b9e09a6e122fba644ded85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d4a/a00147.html#a0ef7a5716b4d58b30bd098de2cafa9db">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4a/a00147.html#ad8323c8329b9e09a6e122fba644ded85">newEvent</a> ()</td></tr>
<tr class="memdesc:ad8323c8329b9e09a6e122fba644ded85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a new event bit.  <a href="#ad8323c8329b9e09a6e122fba644ded85">More...</a><br /></td></tr>
<tr class="separator:ad8323c8329b9e09a6e122fba644ded85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d381ca0129d55d6bb6fec9404f4850e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4a/a00147.html#a9d381ca0129d55d6bb6fec9404f4850e">signal</a> (const <a class="el" href="../../d0/d4a/a00147.html#a0ef7a5716b4d58b30bd098de2cafa9db">Mask</a> eventMask, void(*onUnhandledEvent)(<a class="el" href="../../d0/d4a/a00147.html#a0ef7a5716b4d58b30bd098de2cafa9db">Mask</a>)=NULL)</td></tr>
<tr class="memdesc:a9d381ca0129d55d6bb6fec9404f4850e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal event(s).  <a href="#a9d381ca0129d55d6bb6fec9404f4850e">More...</a><br /></td></tr>
<tr class="separator:a9d381ca0129d55d6bb6fec9404f4850e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac795433598202667a223acd50c952e3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d4a/a00147.html#a0ef7a5716b4d58b30bd098de2cafa9db">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4a/a00147.html#ac795433598202667a223acd50c952e3c">wait</a> (const <a class="el" href="../../d0/d4a/a00147.html#a0ef7a5716b4d58b30bd098de2cafa9db">Mask</a> eventMask)</td></tr>
<tr class="memdesc:ac795433598202667a223acd50c952e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for at least one event.  <a href="#ac795433598202667a223acd50c952e3c">More...</a><br /></td></tr>
<tr class="separator:ac795433598202667a223acd50c952e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb1492827e05d431b726842caede3b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d4a/a00147.html#a0ef7a5716b4d58b30bd098de2cafa9db">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4a/a00147.html#a8cb1492827e05d431b726842caede3b0">wait</a> (const boost::posix_time::time_duration &amp;duration, <a class="el" href="../../d0/d4a/a00147.html#a0ef7a5716b4d58b30bd098de2cafa9db">Mask</a> eventMask)</td></tr>
<tr class="memdesc:a8cb1492827e05d431b726842caede3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait a limited time for at least one event.  <a href="#a8cb1492827e05d431b726842caede3b0">More...</a><br /></td></tr>
<tr class="separator:a8cb1492827e05d431b726842caede3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a436a98d49a060fde1b270620dfaf32bf"><td class="memItemLeft" align="right" valign="top">boost::condition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4a/a00147.html#a436a98d49a060fde1b270620dfaf32bf">m_condAnyEvent</a></td></tr>
<tr class="memdesc:a436a98d49a060fde1b270620dfaf32bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition to signal any event.  <a href="#a436a98d49a060fde1b270620dfaf32bf">More...</a><br /></td></tr>
<tr class="separator:a436a98d49a060fde1b270620dfaf32bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa713a29218ae03e4cdb77a6ad432dac7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d4a/a00147.html#a0ef7a5716b4d58b30bd098de2cafa9db">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4a/a00147.html#aa713a29218ae03e4cdb77a6ad432dac7">m_events</a></td></tr>
<tr class="memdesc:aa713a29218ae03e4cdb77a6ad432dac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-set, each bit represents one user-defined event.  <a href="#aa713a29218ae03e4cdb77a6ad432dac7">More...</a><br /></td></tr>
<tr class="separator:aa713a29218ae03e4cdb77a6ad432dac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcaf5936bfcba0179829c9358e90efd"><td class="memItemLeft" align="right" valign="top">boost::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4a/a00147.html#a8bcaf5936bfcba0179829c9358e90efd">m_mtxMonitor</a></td></tr>
<tr class="memdesc:a8bcaf5936bfcba0179829c9358e90efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to implement the monitor concept.  <a href="#a8bcaf5936bfcba0179829c9358e90efd">More...</a><br /></td></tr>
<tr class="separator:a8bcaf5936bfcba0179829c9358e90efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b215ad25d13f1ea7d11d4f9f76c5a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d4a/a00147.html#a0ef7a5716b4d58b30bd098de2cafa9db">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4a/a00147.html#a65b215ad25d13f1ea7d11d4f9f76c5a1">m_nextNewEvent</a></td></tr>
<tr class="memdesc:a65b215ad25d13f1ea7d11d4f9f76c5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The next event returned by NewEvent().  <a href="#a65b215ad25d13f1ea7d11d4f9f76c5a1">More...</a><br /></td></tr>
<tr class="separator:a65b215ad25d13f1ea7d11d4f9f76c5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Thread-safe handler for a group of events. </p>
<dl class="section date"><dt>Date</dt><dd>Apr 8, 2015</dd></dl>
<p>This class monitors <em>signalling</em> and <em>waiting</em> of multiple events. It implements the "Monitor Object" programming pattern.</p>
<p>A thread can call <a class="el" href="../../d0/d4a/a00147.html#ac795433598202667a223acd50c952e3c" title="Wait for at least one event. ">wait()</a> to wait for one or more events. This will block the thread (consuming no CPU time anymore) until another thread calls <a class="el" href="../../d0/d4a/a00147.html#a9d381ca0129d55d6bb6fec9404f4850e" title="Signal event(s). ">signal()</a> for one of these events. As soon as the other thread calls <a class="el" href="../../d0/d4a/a00147.html#a9d381ca0129d55d6bb6fec9404f4850e" title="Signal event(s). ">signal()</a> for that event the blocked thread enters the ready-state and both threads continue running.</p>
<p>This class extends boost::condition which is &quot;a synchronization primitive used to cause a thread to wait until a particular shared-data condition (or time) is met&quot; (see documentation of boost::condition). In contrast to boost::condition, this class can wait for multiple events similar to <code>WaitForMultipleObjects()</code> of the Windows API.</p>
<p>An event is represented by one bit out of an uint32_t. It is selected for <em>signalling</em> if the corresponding event bit is <code>true</code>. The <a class="el" href="../../d0/d4a/a00147.html" title="Thread-safe handler for a group of events. ">EventMonitor</a> may contain up to 32 user-defined bits. The events are <em>automatic</em>, i.e. the corresponding bits are buffered and keep their states until they are read, which means that one thread waits for this event bit. After that, they are automatically reset to <em>not</em> <em>signalled</em>.</p>
<p>Since events are used for communication between threads, special care must be taken when accessing events. The <a class="el" href="../../d0/d4a/a00147.html" title="Thread-safe handler for a group of events. ">EventMonitor</a> provides thread-safe read methods (called <a class="el" href="../../d0/d4a/a00147.html#ac795433598202667a223acd50c952e3c" title="Wait for at least one event. ">wait()</a>) and write methods (called <a class="el" href="../../d0/d4a/a00147.html#a9d381ca0129d55d6bb6fec9404f4850e" title="Signal event(s). ">signal()</a>) to modify event bits.</p>
<p>This class uses Boost threads for synchronization. Code examples for using Boost threads can be found on Linux system in the folder <a href="file:///usr/share/doc/libboost-doc/examples/libs/thread/example">file:///usr/share/doc/libboost-doc/examples/libs/thread/example</a> .</p>
<p>The <a class="el" href="../../d0/d4a/a00147.html#ac795433598202667a223acd50c952e3c" title="Wait for at least one event. ">wait()</a> methods in this class behave similar to the function <code>WaitForMultipleObjects()</code> known from the Microsoft Windows API. <code>WaitForMultipleObjects()</code> is reimplemented here by means of the Boost library based on the ideas from <a href="http://aspn.activestate.com/ASPN/Mail/Message/boost/1155002">http://aspn.activestate.com/ASPN/Mail/Message/boost/1155002</a> . </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a0ef7a5716b4d58b30bd098de2cafa9db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d0/d4a/a00147.html#a0ef7a5716b4d58b30bd098de2cafa9db">ibeo::common::sdk::EventMonitor::Mask</a> =  uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data type of an event mask. </p>
<p>Variables of this type contain a bit mask that represents a combination of zero or more events. Note that each bit corresponds to an event. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="ab9de610a54e0a03d5cbb0a354d31a2d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d0/d4a/a00147.html#ab9de610a54e0a03d5cbb0a354d31a2d8">ibeo::common::sdk::EventMonitor::StandardEventMasks</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration of standard event masks. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ab9de610a54e0a03d5cbb0a354d31a2d8a09a1f410af6d0856ae7520fd3bf75e93"></a>TimeOutEvent&#160;</td><td class="fielddoc">
<p>Bit mask for the time-out event. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae1a1d19bbcf446d239930df4c1885fec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibeo::common::sdk::EventMonitor::EventMonitor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad8323c8329b9e09a6e122fba644ded85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d4a/a00147.html#a0ef7a5716b4d58b30bd098de2cafa9db">EventMonitor::Mask</a> ibeo::common::sdk::EventMonitor::newEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a new event bit. </p>
<dl class="section return"><dt>Returns</dt><dd>The new event bit or 0 if there are no more events available. The current implementation supports up to 32 events per <a class="el" href="../../d0/d4a/a00147.html" title="Thread-safe handler for a group of events. ">EventMonitor</a> object. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d381ca0129d55d6bb6fec9404f4850e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibeo::common::sdk::EventMonitor::signal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d4a/a00147.html#a0ef7a5716b4d58b30bd098de2cafa9db">Mask</a>&#160;</td>
          <td class="paramname"><em>eventMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="../../d0/d4a/a00147.html#a0ef7a5716b4d58b30bd098de2cafa9db">Mask</a>)&#160;</td>
          <td class="paramname"><em>onUnhandledEvent</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal event(s). </p>
<p>All waiting threads will be notified about the signalled event(s). All active (non-waiting) threads will detect the event(s) upon their next <a class="el" href="../../d0/d4a/a00147.html#ac795433598202667a223acd50c952e3c" title="Wait for at least one event. ">wait()</a> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventMask</td><td>Bit mask of the events to signal. To signal more than one event combine the corresponding bits with a logical OR. </td></tr>
    <tr><td class="paramname">onUnhandledEvent</td><td>optional pointer to a function that is called back if any of the bits in <em>eventMask</em> is still set, i.e. if an event has not been handled yet. This feature can be used e.g. to detect real-time violations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac795433598202667a223acd50c952e3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d4a/a00147.html#a0ef7a5716b4d58b30bd098de2cafa9db">EventMonitor::Mask</a> ibeo::common::sdk::EventMonitor::wait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d4a/a00147.html#a0ef7a5716b4d58b30bd098de2cafa9db">Mask</a>&#160;</td>
          <td class="paramname"><em>eventMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for at least one event. </p>
<p>If the event has been signalled already since the last <a class="el" href="../../d0/d4a/a00147.html#ac795433598202667a223acd50c952e3c" title="Wait for at least one event. ">wait()</a> call, thread execution continues immediately. Otherwise, the thread will wait until one of the specified events is signalled. The event bits are reset automatically when <a class="el" href="../../d0/d4a/a00147.html#ac795433598202667a223acd50c952e3c" title="Wait for at least one event. ">wait()</a> returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventMask</td><td>Bit mask of the expected events. To wait for more than one event combine the corresponding bits using logical OR. value should be non-null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit mask of the events that have waked up the thread. Multiple events are logically OR'ed in the mask.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Multiple events will be returned if any of the following conditions is true:<ul>
<li>Multiple events are passed to <a class="el" href="../../d0/d4a/a00147.html#a9d381ca0129d55d6bb6fec9404f4850e" title="Signal event(s). ">signal()</a>.</li>
<li>While handling an event, at least two different events are signalled by other threads. These new events will be returned altogether at the next <a class="el" href="../../d0/d4a/a00147.html#ac795433598202667a223acd50c952e3c" title="Wait for at least one event. ">wait()</a> call (assuming that <em>eventMask</em> matches).</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/d4a/a00147.html#a8cb1492827e05d431b726842caede3b0" title="Wait a limited time for at least one event. ">wait(const boost::posix_time::time_duration&amp;, Mask)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8cb1492827e05d431b726842caede3b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d4a/a00147.html#a0ef7a5716b4d58b30bd098de2cafa9db">EventMonitor::Mask</a> ibeo::common::sdk::EventMonitor::wait </td>
          <td>(</td>
          <td class="paramtype">const boost::posix_time::time_duration &amp;&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d4a/a00147.html#a0ef7a5716b4d58b30bd098de2cafa9db">Mask</a>&#160;</td>
          <td class="paramname"><em>eventMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait a limited time for at least one event. </p>
<p>The same as <a class="el" href="../../d0/d4a/a00147.html#ac795433598202667a223acd50c952e3c" title="Wait for at least one event. ">wait(Mask)</a>, but waiting is canceled if none of the specified events is signaled within the specified duration or shortly after that, depending on when this thread is scheduled again by the operating system scheduler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>The approximate time limit for waiting, e.g. <code>boost::posix_time::milliseconds(100)</code>. Keep in mind this is only a minimum time for waiting. There is no guarantee that this thread will wake up after exactly the time specified. The operating system scheduler might choose to wait much longer than this requested waiting duration to activate this thread again, especially if another thread is still active. That being said, the accuracy for the waiting time on Linux seems to be approx. 1-2 milliseconds, whereas on Windows the accuracy is significantly worse and has been observed to be anything between 3 and 40 milliseconds.//! </td></tr>
    <tr><td class="paramname">eventMask</td><td>Bit mask of the events to signal. To wait for more than one event combine the corresponding bits with a logical OR. Value must be non-null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit mask of the events that have woken up the thread or EventMonitor::timeOutEvent. Multiple events are combined in the mask using logical <code>OR</code>. See also note at <a class="el" href="../../d0/d4a/a00147.html#ac795433598202667a223acd50c952e3c" title="Wait for at least one event. ">wait(Mask)</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/d4a/a00147.html#ac795433598202667a223acd50c952e3c" title="Wait for at least one event. ">wait(Mask)</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a436a98d49a060fde1b270620dfaf32bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::condition ibeo::common::sdk::EventMonitor::m_condAnyEvent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Condition to signal any event. </p>
<p>Threads can wait for events. Signaling this condition wakes them up. Note that the signal will be detected by <em>waiting</em> threads only. </p>

</div>
</div>
<a class="anchor" id="aa713a29218ae03e4cdb77a6ad432dac7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d4a/a00147.html#a0ef7a5716b4d58b30bd098de2cafa9db">Mask</a> ibeo::common::sdk::EventMonitor::m_events</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit-set, each bit represents one user-defined event. </p>
<p>The number of events is limited by the word size, currently 32. </p>

</div>
</div>
<a class="anchor" id="a8bcaf5936bfcba0179829c9358e90efd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::mutex ibeo::common::sdk::EventMonitor::m_mtxMonitor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex to implement the monitor concept. </p>
<p>The so-called <em>monitor</em> ensures that each (public) method of this class is executed only by a single thread at a time. </p>

</div>
</div>
<a class="anchor" id="a65b215ad25d13f1ea7d11d4f9f76c5a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d4a/a00147.html#a0ef7a5716b4d58b30bd098de2cafa9db">Mask</a> ibeo::common::sdk::EventMonitor::m_nextNewEvent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The next event returned by NewEvent(). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="../../da/d5b/a00868_source.html">EventMonitor.hpp</a></li>
<li><a class="el" href="../../d2/db8/a00867.html">EventMonitor.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 17 2020 15:12:31 for SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
